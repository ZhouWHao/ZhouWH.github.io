<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zwh | Blog</title>
  <subtitle>天下风云出我辈，一入公司岁月催。十指无力眼睛花，脖痛腰老肩膀脆。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-23T03:00:28.557Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zwh Blog</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你觉得和珅是好官还是贪官？</title>
    <link href="http://yoursite.com/2016/12/23/zwh10/"/>
    <id>http://yoursite.com/2016/12/23/zwh10/</id>
    <published>2016-12-23T03:00:00.000Z</published>
    <updated>2016-12-23T03:00:28.557Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/heshen.png" alt=""><br>&emsp;&emsp;行行行，君忠我奸，君廉我贪，君贤我恶，嗯，行吧，天下清名被你占光，天下恶名被我占光。那你我岂能不饮上一杯？<br><a id="more"></a></p>
<embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=7478050&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/heshen.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;行行行，君忠我奸，君廉我贪，君贤我恶，嗯，行吧，天下清名被你占光，天下恶名被我占光。那你我岂能不饮上一杯？&lt;br&gt;
    
    </summary>
    
    
      <category term="电视剧" scheme="http://yoursite.com/tags/%E7%94%B5%E8%A7%86%E5%89%A7/"/>
    
  </entry>
  
  <entry>
    <title>如何在6个月内学会英语</title>
    <link href="http://yoursite.com/2016/12/10/zwh8/"/>
    <id>http://yoursite.com/2016/12/10/zwh8/</id>
    <published>2016-12-10T02:33:00.000Z</published>
    <updated>2016-12-13T06:38:44.650Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/English.png" alt=""><br>&emsp;&emsp;整个过程就是试错，得到反馈，迅速纠正，练习，继续循环，最终学会。<br><a id="more"></a></p>
<embed height="700" width="850" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=5994366&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/English.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;整个过程就是试错，得到反馈，迅速纠正，练习，继续循环，最终学会。&lt;br&gt;
    
    </summary>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化这几年太先进，先进得我都不认识它了</title>
    <link href="http://yoursite.com/2016/12/10/zwh9/"/>
    <id>http://yoursite.com/2016/12/10/zwh9/</id>
    <published>2016-12-10T02:33:00.000Z</published>
    <updated>2016-12-23T04:10:11.835Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/module.png" alt=""><br>&emsp;&emsp;<br><a id="more"></a></p>
<h2 id="一、什么是模块？"><a href="#一、什么是模块？" class="headerlink" title="一、什么是模块？"></a>一、什么是模块？</h2><p><strong>定义</strong>：具有相同属性和行为的事物的集合</p>
<p><strong>在前端中</strong>：将一些属性比较类似和行为比较类似的内容放在同一个js文件里面，把这个js文件称为模块</p>
<p><strong>目的</strong>：为了每个js文件只关注与自身有关的事情，让每个js文件各行其职</p>
<h2 id="二、什么是模块化？CommonJS是什么？AMD和CMD又是什么？"><a href="#二、什么是模块化？CommonJS是什么？AMD和CMD又是什么？" class="headerlink" title="二、什么是模块化？CommonJS是什么？AMD和CMD又是什么？"></a>二、什么是模块化？CommonJS是什么？AMD和CMD又是什么？</h2><p><strong>①模块化</strong>：指的就是遵守commonjs规范，解决不同js模块之间相互调用问题</p>
<p><strong>②CommonJS</strong>：</p>
<p>1. A.js文件中调用另一个B.js文件，一定要在A.js中引入B.js</p>
<div class="highlight"><br><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(<span class="string">"B.js"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure><br><br></div>

<p>2. 另一个被调用的js，也就是B.js一定要对外提供接口。</p>
<div class="highlight"><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span>.<span class="keyword">exports</span>=B;</div></pre></td></tr></table></figure><br><br></div>

<p>过程如下：</p>
<p>B.js</p>
<div class="highlight"><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">javascript</div><div class="line">var b = <span class="string">"Hello,I'm module B."</span>;</div><div class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = b;<span class="comment">//暴露一个接口，与b对接。这个接口既可以是函数，也可以是对象，甚至是数组。</span></div></pre></td></tr></table></figure><br><br></div>

<p>A.js</p>
<div class="highlight"><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">javascript</div><div class="line"><span class="keyword">var</span> _b = <span class="built_in">require</span>(<span class="string">"./B.js"</span>);<span class="comment">//实际过程中应当是B.js相对于A.js的路径，这比使用绝对路径去获取要规范得多</span></div><div class="line"><span class="comment">//此时_b获得了B.js的接口，这个接口指向B.js中的变量b</span></div><div class="line"><span class="built_in">console</span>.log( _b );<span class="comment">//"Hello,I'm module B.";</span></div></pre></td></tr></table></figure><br><br></div>

<p>这就实现了一个简单的模块化工作方式，即：</p>
<p><strong>模块间相互调用，协同工作，实现某特定功能。</strong></p>
<p><strong>④AMD规范</strong>：Async Module Define 异步模块声明</p>
<p><strong>⑤CMD规范</strong>：Common Module Define 公共模块声明</p>
<p><strong>⑥模块化的核心价值</strong>：模块化最核心的价值在于解决不同文件之间的分工和调用问题，即依赖关系。</p>
<h2 id="三、模块化的一些工具"><a href="#三、模块化的一些工具" class="headerlink" title="三、模块化的一些工具"></a>三、模块化的一些工具</h2><ul>
<li><p>gulp + browerify</p>
</li>
<li><p>构建步骤：</p>
</li>
</ul>
<p>1. 安装gulp</p>
<div class="highlight"><br><br><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install gulp --<span class="built_in">save</span>-<span class="built_in">dev</span> <span class="comment">//要安装全局还是本地依赖根据实际情况来</span></div></pre></td></tr></table></figure><br><br></div>

<p>2. 安装browserify –save–dev</p>
<div class="highlight"><br><br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">npm</span> <span class="comment">install</span> <span class="comment">browserify</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">save</span><span class="literal">-</span><span class="literal">-</span><span class="comment">dev</span></div></pre></td></tr></table></figure><br><br></div>

<p>3. 安装文件输出流工具</p>
<div class="highlight"><br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> vinyl-<span class="keyword">source</span>-stream <span class="comment">--save-dev</span></div></pre></td></tr></table></figure><br><br></div>

<p>4. 在gulpfile里编写任务实现模块化</p>
<p>gulpfile.js</p>
<div class="highlight"><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本模块引入</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> brow = <span class="built_in">require</span>(<span class="string">'browerify'</span>);</div><div class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);</div><div class="line"><span class="comment">//任务编写</span></div><div class="line">gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//将任务交付给browserify</span></div><div class="line"><span class="comment">//brow读取入口文件后，能自动查找相互之间有依赖的关系的模块</span></div><div class="line">  <span class="keyword">return</span> brow(<span class="string">'./entry.js'</span>)</div><div class="line">  .bundle()<span class="comment">//输出一个文件流变量（gulp的工作机制）</span></div><div class="line">  .pipe(source(<span class="string">'bundle.js'</span>))<span class="comment">//将文件流变量输出为文件</span></div><div class="line">  .pipe(gulp.dest(<span class="string">'js'</span>));<span class="comment">//将文件最终输出</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></div>

<ul>
<li>webpack</li>
</ul>
<p>参考[webpack的配置及使用][1]</p>
<ul>
<li><p>requireJS</p>
</li>
<li><p>模块声明规范：AMD</p>
</li>
<li><p>声明模块</p>
</li>
<li><p>参数1：id 是这个模块的名称，它是一个可选参数，默认为require加载此模块时指定的名称，若定义这个参数，那么这个模块名应当为“顶级”的，不允许相对名称。</p>
</li>
<li><p>参数2：数组，为这个模块所依赖的其他模块</p>
</li>
<li><p>匿名函数参数：为依赖模块在这个模块中的接口，它们是一一对应的，因此即便不需要某个模块的接口，但若是需要它后面模块的接口，那也必须给它增加一个用于占位的参数。</p>
</li>
</ul>
<div class="highlight"><br><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">define( <span class="string">'id'</span>, [ <span class="string">'module1'</span>, <span class="string">'module2'</span> ], <span class="function"><span class="keyword">function</span><span class="params">( m1, m2 )</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    arg1: m1,</div><div class="line">    arg2: m2</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//返回值即是module3的接口</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><br><br></div>

<ul>
<li>使用步骤</li>
</ul>
<p>1. 下载requireJS</p>
<div class="highlight"><br><br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install requirejs<span class="comment">//根据个人习惯选择下载方式，只要保证后续引入的路径正确</span></div></pre></td></tr></table></figure><br><br></div>

<p>2. 配置config文件和main.js</p>
<p>config.js</p>
<div class="highlight"><br><br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">require</span><span class="selector-class">.config</span>( &#123;</div><div class="line">  <span class="attribute">base</span>: <span class="string">''</span>,<span class="comment">//引入模块的起始路径</span></div><div class="line">  <span class="comment">//paths对象为要引入的模块的名称及路径，且不需.js后缀，require默认会为文件添加.js后缀</span></div><div class="line">  <span class="attribute">paths</span>: &#123;</div><div class="line">    <span class="string">'jquery'</span>: <span class="string">'./jquery-1.11.0'</span><span class="comment">//这就引入了juery作为一个模块。 PS：jquery自己已经实现了AMD，并且'jquery'是一个顶级模块名。</span></div><div class="line">  &#125;</div><div class="line">&#125; );</div></pre></td></tr></table></figure><br><br></div>

<p>main.js</p>
<div class="highlight"><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"> $ </span>) </span>&#123;</div><div class="line">  $(<span class="built_in">document</span>).css(<span class="string">"background"</span>, <span class="string">"#000"</span>);<span class="comment">//这就实现了引入使用jquery模块，并用它进行dom操作</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><br><br></div>

<p>3. 在页面中引入</p>
<div class="highlight"><br><br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script data-main=<span class="string">"./main.js"</span> src=<span class="string">"./bower-components/requirejs/dist/require.js&gt;&lt;/script&gt;</span></div><div class="line"><span class="comment">//main即是主逻辑入口文件</span></div></pre></td></tr></table></figure><br><br></div>

<ul>
<li><p>SeaJS</p>
</li>
<li><p>模块声明规范：CMD</p>
</li>
<li><p>声明模块</p>
</li>
</ul>
<div class="highlight"><br><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define( <span class="function"><span class="keyword">function</span>(<span class="params"> <span class="built_in">require</span>, exports, <span class="built_in">module</span> </span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = <span class="built_in">require</span>(<span class="string">'./Controller.js'</span>);</div><div class="line">  c();</div><div class="line">&#125;)</div></pre></td></tr></table></figure><br><br></div>

<ul>
<li>使用步骤</li>
</ul>
<p>1. 下载seajs</p>
<div class="highlight"><br><br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install seajs<span class="comment">//这里根据个人习惯下载seajs的包，只要引入时路径正确就行</span></div></pre></td></tr></table></figure><br><br></div>

<p>2. 配置seajs.config</p>
<div class="highlight"><br><br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">seajs</span><span class="selector-class">.config</span>(&#123;</div><div class="line">  <span class="attribute">base</span>: <span class="string">'./'</span>, <span class="comment">//模块起始路径</span></div><div class="line">&#125;)</div><div class="line"><span class="selector-tag">seajs</span><span class="selector-class">.use</span>(<span class="string">'./main'</span>);<span class="comment">//使用主逻辑入口文件，相当于requirejs中的data-main文件</span></div></pre></td></tr></table></figure><br><br></div>

<p><strong>requireJS和SeaJS都是在前端实现模块化，相当于一个前端的js模块化加载器，和webpack不一样，webpack是通过nodejs将文件打包的。</strong></p>
<h2 id="四、模块化案例"><a href="#四、模块化案例" class="headerlink" title="四、模块化案例"></a>四、模块化案例</h2><p><strong>前端mvc架构</strong></p>
<ul>
<li><p><strong>Vue</strong> 组件化&amp;模块化</p>
</li>
<li><p><strong>React</strong> 组件化&amp;模块化</p>
</li>
<li><p><strong>node.js</strong> 每个文件都是模块</p>
</li>
</ul>
<p><strong>什么是MVC</strong></p>
<ul>
<li>后端开发的一种概念</li>
</ul>
<p><em>即view( html + js + css + img ) + controller( 控制层 ) + model( 数据模型 )</em></p>
<ul>
<li><p>前端演变了一套MVC体系：</p>
</li>
<li><p><strong>veiw</strong>( html + css + js )</p>
</li>
</ul>
<p><em>写静态页面 css、js、img及效果</em></p>
<ul>
<li><strong>controller</strong>( 专注于实现服务和逻辑控制的层面叫做控制器 )</li>
</ul>
<p><em>监听页面中请求和事件，处理请求和事件；向model请求数据，得到数据后绑定到页面</em></p>
<ul>
<li><strong>model</strong> ( 数据变量 || ajax从服务端取回的数据 )</li>
</ul>
<p><strong>对外提供一些数据</strong></p>
<p><u>体现了一种分层的概念，让每个层面只做自己该做的行为，减少代码耦合和冗余</u></p>
<p><strong>为什么使用MVC？</strong></p>
<p><strong>低耦合：</strong></p>
<p>MVC将业务分为三层，减少了数据与业务的耦合性，增强了各层次功能的独立性，使得在需求改变时可能只需要改变其中一层就能完成服务；</p>
<p><strong>复用性高：</strong></p>
<p>三层业务功能分明，耦合度低，使各模块可以独立完成自身功能，降低了依赖性，具有很高的复用性。</p>
<p><strong>利于批量生产和扩展：</strong></p>
<p>复用性高使得在批量生产的时候可以根据需求进行模块的重用，加快了生产效率。并且模块化使得扩展也非常方便，模块只需根据规范进行编写，经审核后引入便可以实现扩展。</p>
<p><strong>利于协作开发：</strong></p>
<p>扩展性强使协作开发也变得非常方便，每个人根据自己的分工设计自己的模块，不与他人冲突，引入时也各行其职。</p>
<p><strong>推广普及度高：</strong></p>
<p>由于对协作开发的友好，使得MVC模式大受开发者的欢迎，使用这个模式的产品的推广和普及变得容易得多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/module.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;&lt;br&gt;
    
    </summary>
    
    
      <category term="前端模块化管理" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Javascript全栈之道</title>
    <link href="http://yoursite.com/2016/12/10/zwh7/"/>
    <id>http://yoursite.com/2016/12/10/zwh7/</id>
    <published>2016-12-10T02:33:00.000Z</published>
    <updated>2016-12-10T04:09:10.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/fullstack.png" alt=""></p>
<p>JavaScript 全栈工程师培训教程</p>
<a id="more"></a>
<h2 id="一、培训准备"><a href="#一、培训准备" class="headerlink" title="一、培训准备"></a>一、培训准备</h2><p>参加培训的学员，事先应该做好以下准备工作。</p>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><ul>
<li>掌握 HTML、CSS、JS 的基本用法</li>
<li>掌握命令行的基本用法<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2></li>
</ul>
<p>请到官网 git-scm.com 或国内的下载站，下载安装包。</p>
<h2 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a>安装 Node</h2><p>请到 Node 官网nodejs.org，或者国内镜像npm.taobao.org/mirrors/node，下载安装包。推荐安装最新的稳定版，目前是v6.x。</p>
<p>安装完成后，命令行执行下面的命令，确认是否安装成功。</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node -v</div><div class="line">v6.9.1</div></pre></td></tr></table></figure>
</code></pre><p>Node 的模块管理器 npm 会一起安装好。由于 Node 的官方模块仓库网速太慢，模块仓库需要切换到阿里的源。</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</div></pre></td></tr></table></figure>
</code></pre><p>执行下面的命令，确认是否切换成功。<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config get registry</div></pre></td></tr></table></figure></p>
<h2 id="安装-Postman"><a href="#安装-Postman" class="headerlink" title="安装 Postman"></a>安装 Postman</h2><p>Postman 是一个 HTTP 通信测试工具，REST API 的练习会用到它。</p>
<p>请到官网 GetPostman.com 下载独立安装包；也可以参考这篇文章www.cnblogs.com/mafly/p/postman.html，下载 Chrome 浏览器的插件，它们的效果一样。</p>
<h2 id="安装示例库"><a href="#安装示例库" class="headerlink" title="安装示例库"></a>安装示例库</h2><p>所有的讲义和练习源码，都是开源的，网址是 github.com/ruanyf/jstraining。执行下面的命令，将这个库拷贝到你的硬盘上。<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Linux &amp; Mac</span></div><div class="line">$ git <span class="built_in">clone</span> git@github.com:ruanyf/jstraining.git</div><div class="line"></div><div class="line"><span class="comment"># Windows</span></div><div class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/jstraining.git</div></pre></td></tr></table></figure></p>
<p>如果因为种种原因，Git 命令行无法使用，也可以直接下载压缩包，地址是 <a href="https://github.com/ruanyf/jstraining/archive/master.zip" target="_blank" rel="external">https://github.com/ruanyf/jstraining/archive/master.zip</a> 。</p>
<h2 id="二、前端开发的历史和趋势"><a href="#二、前端开发的历史和趋势" class="headerlink" title="二、前端开发的历史和趋势"></a>二、前端开发的历史和趋势</h2><hr>
<h2 id="什么是前端"><a href="#什么是前端" class="headerlink" title="什么是前端"></a>什么是前端</h2><ul>
<li>前端：针对浏览器的开发，代码在浏览器运行</li>
<li>后端：针对服务器的开发，代码在服务器运行</li>
</ul>
<p><img src="/assets/blogImg/webandserver.png" alt=""></p>
<hr>
<h2 id="前后端不分的时代"><a href="#前后端不分的时代" class="headerlink" title="前后端不分的时代"></a>前后端不分的时代</h2><p>互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。</p>
<ol>
<li>后端收到浏览器的请求</li>
<li>生成静态页面</li>
<li>发送到浏览器</li>
</ol>
<hr>
<h2 id="后端-MVC-的开发模式"><a href="#后端-MVC-的开发模式" class="headerlink" title="后端 MVC 的开发模式"></a>后端 MVC 的开发模式</h2><p>那时的网站开发，采用的是后端 MVC 模式。</p>
<ul>
<li>Model（模型层）：提供/保存数据</li>
<li>Controller（控制层）：数据处理，实现业务逻辑</li>
<li>View（视图层）：展示数据，提供用户界面</li>
</ul>
<p>前端只是后端 MVC 的 V。</p>
<hr>
<p>以 PHP 框架 Laravel 为例。</p>
<p><img src="/assets/blogImg/phpflow.png" alt=""></p>
<hr>
<h2 id="前端工程师的角色"><a href="#前端工程师的角色" class="headerlink" title="前端工程师的角色"></a>前端工程师的角色</h2><p>那时的前端工程师，实际上是模板工程师，负责编写页面模板。</p>
<p>后端代码读取模板，替换变量，渲染出页面。</p>
<hr>
<h2 id="典型的-PHP-模板"><a href="#典型的-PHP-模板" class="headerlink" title="典型的 PHP 模板"></a>典型的 PHP 模板</h2><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Car &#123;&#123; $car-&gt;id &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Car &#123;&#123; $car-&gt;id &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Make: &#123;&#123; $car-&gt;make &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Model: &#123;&#123; $car-&gt;model &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre><hr>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax 技术诞生，改变了一切。</p>
<ul>
<li>2004年：Gmail</li>
<li>2005年：Google 地图</li>
</ul>
<p>前端不再是后端的模板，可以独立得到各种数据。</p>
<hr>
<p><img src="/assets/blogImg/web20.gif" alt=""></p>
<p>Ajax 技术促成了 Web 2.0 的诞生。</p>
<p>web2.png</p>
<ul>
<li>Web 1.0：静态网页，纯内容展示</li>
<li>Web 2.0：动态网页，富交互，前端数据处理</li>
</ul>
<p>从那时起，前端变得复杂了，对前端工程师的要求越来越高。</p>
<hr>
<p>前端 MVC 框架</p>
<p>前端通过 Ajax 得到数据，因此也有了处理数据的需求。</p>
<p>前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。</p>
<ul>
<li>2010年，Backbone.js</li>
</ul>
<p><img src="/assets/blogImg/Backbone.png" alt=""></p>
<hr>
<h2 id="Backbone-js"><a href="#Backbone-js" class="headerlink" title="Backbone.js"></a>Backbone.js</h2><p>Backbone 将前端代码分成两个基本部分。</p>
<ul>
<li>Model：管理数据</li>
<li>View：数据的展现</li>
</ul>
<p><img src="/assets/blogImg/backbone-model-view.png" alt=""></p>
<hr>
<h2 id="前端-Controller"><a href="#前端-Controller" class="headerlink" title="前端 Controller"></a>前端 Controller</h2><p>Backbone 只有 M 和 V，没有 C。因为，前端 Controller 与后端不同。</p>
<ul>
<li>不需要，也不应该处理业务逻辑</li>
<li>只需要处理 UI 逻辑，响应用户的一举一动</li>
</ul>
<p>所以，前端 Controller 相对比较简单。Backbone 没有 C，只用事件来处理 UI 逻辑。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">var</span> AppView = Backbone.View.extend(&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">events: &#123;</div><div class="line"></div><div class="line">  <span class="string">"keypress #new-todo"</span>:  <span class="string">"createOnEnter"</span>,</div><div class="line"></div><div class="line">  <span class="string">"click #clear-completed"</span>: <span class="string">"clearCompleted"</span>,</div><div class="line"></div><div class="line">  <span class="string">"click #toggle-all"</span>: <span class="string">"toggleAllComplete"</span></div><div class="line"></div><div class="line">&#125;,</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>前端还有一种天然的方法，可以切换视图，那就是 URL。</p>
<p>通过 URL 切换视图，这就是 Router（路由）的作用。以 Backbone 为例。</p>
<p><img src="/assets/blogImg/backbone-routing.png" alt=""></p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">App.Router = Backbone.Router.extend(&#123;</div><div class="line">  <span class="attr">routes</span>: &#123;</div><div class="line"><span class="string">''</span>: <span class="string">'index'</span>,</div><div class="line"><span class="string">'show'</span>: <span class="string">'show'</span></div><div class="line">&#125;,</div><div class="line">  <span class="attr">index</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">$(<span class="built_in">document</span>.body).append(<span class="string">"调用了 Index 路由"</span>);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">show</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">$(<span class="built_in">document</span>.body).append(<span class="string">"调用了 Show 路由"</span>);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><hr>
<h2 id="示例：Backbone-Router"><a href="#示例：Backbone-Router" class="headerlink" title="示例：Backbone Router"></a>示例：Backbone Router</h2><p>打开demos/backbone-demo/index.html，按照《操作说明》，查看示例。</p>
<p><img src="/assets/blogImg/BackboneRouting.png" alt=""></p>
<hr>
<h2 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h2><p>另一些框架提出 MVVM 模式，用 View Model 代替 Controller。</p>
<ul>
<li>Model</li>
<li>View</li>
<li>View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。</li>
</ul>
<p>本质：view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。</p>
<p><img src="/assets/blogImg/MVVM.png" alt=""></p>
<hr>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>前端可以做到：</p>
<ul>
<li>读写数据</li>
<li>切换视图</li>
<li>用户交互</li>
</ul>
<p>这意味着，网页其实是一个应用程序。</p>
<p>SPA = Single-page application<br>2010年后，前端工程师从开发页面，变成了开发”前端应用“（跑在浏览器里面的应用程序）。</p>
<hr>
<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Google 公司推出的 Angular 是最流行的 MVVM 前端框架。</p>
<p>它的风格属于 HTML 语言的增强，核心概念是双向绑定。</p>
<p><img src="/assets/blogImg/angular.png" alt=""></p>
<hr>
<h2 id="示例：Angular-的双向绑定"><a href="#示例：Angular-的双向绑定" class="headerlink" title="示例：Angular 的双向绑定"></a>示例：Angular 的双向绑定</h2><p>浏览器打开demos/angular-demo/index.html，可以看到一个输入框。</p>
<p><img src="/assets/blogImg/zhangsan.png" alt=""></p>
<hr>
<pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">""</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">姓名 :</div><div class="line"><span class="tag">&lt;<span class="name">input</span></span></div><div class="line">  <span class="attr">type</span>=<span class="string">"text"</span></div><div class="line">  <span class="attr">ng-model</span>=<span class="string">"name"</span></div><div class="line">  <span class="attr">placeholder</span>=<span class="string">"在这里输入您的大名"</span></div><div class="line">&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre><hr>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue.js 是现在很热门的一种前端 MVVM 框架。</p>
<p>它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。</p>
<p><img src="/assets/blogImg/vue.png" alt=""></p>
<hr>
<h2 id="示例：Vue-的双向绑定"><a href="#示例：Vue-的双向绑定" class="headerlink" title="示例：Vue 的双向绑定"></a>示例：Vue 的双向绑定</h2><p>Vue 的模板与数据，是双向绑定的。</p>
<p>打开demos/vue-demo/index1.html，按照《操作说明》，查看示例。</p>
<p><img src="/assets/blogImg/VueInput.png" alt=""></p>
<hr>
<p>HTML 代码<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"journal"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JS 代码<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> journal = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#journal'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line"><span class="attr">message</span>: <span class="string">'Your first entry'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><ul>
<li>Ajax -&gt; 前端应用兴起</li>
<li>智能手机 -&gt; 多终端支持<br>这两个原因，导致前端开发方式发生根本的变化。</li>
</ul>
<p>前端不再是后端 MVC 中的 V，而是单独的一层。</p>
<hr>
<h2 id="REST-接口"><a href="#REST-接口" class="headerlink" title="REST 接口"></a>REST 接口</h2><p>前后端分离以后，它们之间通过接口通信。</p>
<p>后端暴露出接口，前端消费后端提供的数据。</p>
<p>后端接口一般是 REST 形式，前后端的通信协议一般是 HTTP。</p>
<hr>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。</p>
<p>Node = JavaScript + 操作系统 API</p>
<p><img src="/assets/blogImg/node-logo.png" alt=""></p>
<hr>
<h2 id="Node-的意义"><a href="#Node-的意义" class="headerlink" title="Node 的意义"></a>Node 的意义</h2><ul>
<li>JavaScript 成为服务器脚本语言，与 Python 和 Ruby 一样</li>
<li>JavaScript 成为唯一的浏览器和服务器都支持的语言</li>
<li>前端工程师可以编写后端程序了</li>
</ul>
<hr>
<h2 id="前端开发模式的根本改变"><a href="#前端开发模式的根本改变" class="headerlink" title="前端开发模式的根本改变"></a>前端开发模式的根本改变</h2><ul>
<li>Node 环境下开发</li>
<li>大量使用服务器端工具</li>
<li>引入持续集成等软件工程的标准流程</li>
<li>开发完成后，编译成浏览器可以运行的脚本，放上 CDN</li>
</ul>
<hr>
<h2 id="全栈工程师"><a href="#全栈工程师" class="headerlink" title="全栈工程师"></a>全栈工程师</h2><p>前端工程师正在转变为全栈工程师</p>
<ul>
<li>一个人负责开发前端和后端</li>
<li>从数据库到 UI 的所有开发</li>
</ul>
<hr>
<h2 id="全栈技能"><a href="#全栈技能" class="headerlink" title="全栈技能"></a>全栈技能</h2><p>怎样才能称为全栈工程师？</p>
<ul>
<li>传统前端技能：HTML、JavaScript、CSS</li>
<li>一门后端语言</li>
<li>移动端开发：iOS / Android / HTML5</li>
<li>其他技能：数据库、HTTP 等等</li>
</ul>
<hr>
<h2 id="软件行业的发展动力"><a href="#软件行业的发展动力" class="headerlink" title="软件行业的发展动力"></a>软件行业的发展动力</h2><p>历史演变：前后端不分 -&gt; 前后端分离 -&gt; 全栈工程师</p>
<p>动力：更加产业化、大规模地生产软件</p>
<ul>
<li>效率更高</li>
<li>成本更低</li>
</ul>
<p>通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高。</p>
<hr>
<h2 id="H5-就是一个最好的例子"><a href="#H5-就是一个最好的例子" class="headerlink" title="H5 就是一个最好的例子"></a>H5 就是一个最好的例子</h2><p>为什么 H5 技术会赢得移动端？</p>
<ul>
<li>开发速度快：Native 需要重新编译才能看到结果，H5 是即时输出</li>
<li>开发成本低：Native 需要两个开发团队，H5 只要一个</li>
<li>快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新</li>
</ul>
<hr>
<h2 id="未来软件的特点"><a href="#未来软件的特点" class="headerlink" title="未来软件的特点"></a>未来软件的特点</h2><ul>
<li>联网</li>
<li>高并发</li>
<li>分布式</li>
<li>跨终端<br>现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。</li>
</ul>
<hr>
<h2 id="未来只有两种软件工程师"><a href="#未来只有两种软件工程师" class="headerlink" title="未来只有两种软件工程师"></a>未来只有两种软件工程师</h2><ul>
<li>端工程师<ul>
<li>手机端</li>
<li>PC 端</li>
<li>TV 端</li>
<li>VR 端</li>
<li>……</li>
</ul>
</li>
<li>云工程师</li>
</ul>
<h1 id="React-技术栈"><a href="#React-技术栈" class="headerlink" title="React 技术栈"></a>React 技术栈</h1><hr>
<p>React 是目前最热门的前端框架。</p>
<ul>
<li>Facebook 公司2013年推出</li>
<li>现在最好的社区支持和生态圈</li>
<li>大量的第三方工具</li>
</ul>
<p><img src="/assets/blogImg/react-logo.png" alt=""></p>
<hr>
<h2 id="React-的优点"><a href="#React-的优点" class="headerlink" title="React 的优点"></a>React 的优点</h2><ul>
<li>组件模式：代码复用和团队分工</li>
<li>虚拟 DOM：性能优势</li>
<li>移动端支持：跨终端</li>
</ul>
<hr>
<h2 id="React-的缺点"><a href="#React-的缺点" class="headerlink" title="React 的缺点"></a>React 的缺点</h2><ul>
<li>学习曲线较陡峭</li>
<li>全新的一套概念，与其他所有框架截然不同</li>
<li>只有采用它的整个技术栈，才能发挥最大威力</li>
</ul>
<p>总结：React 非常先进和强大，但是学习和实现成本都不低</p>
<hr>
<h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myTitle = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<hr>
<h2 id="JSX-语法解释"><a href="#JSX-语法解释" class="headerlink" title="JSX 语法解释"></a>JSX 语法解释</h2><p>（1）JSX 语法的最外层，只能有一个节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">let</span> myTitle = <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p>（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myTitle = <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;'Hello ' + 'World'&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div></pre></td></tr></table></figure>
<hr>
<h2 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h2><p>JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="actionscript"></span></div><div class="line">  <span class="comment">// ** Our code goes here! **</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。</p>
<p>Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。</p>
<hr>
<h2 id="课堂练习：JSX-语法"><a href="#课堂练习：JSX-语法" class="headerlink" title="课堂练习：JSX 语法"></a>课堂练习：JSX 语法</h2><p>浏览器打开<code>demos/jsx-demo/index.html</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#jsx" target="_blank" rel="external">《操作说明》</a>，完成练习。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<h2 id="示例：React-组件"><a href="#示例：React-组件" class="headerlink" title="示例：React 组件"></a>示例：React 组件</h2><p>React 允许用户定义自己的组件，插入网页。</p>
<p>浏览器打开<code>demos/react-component-demo/index1.html</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#react-组件语法" target="_blank" rel="external">《操作说明》</a>，仔细查看源码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">MyTitle</span>/&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<h2 id="课堂练习：组件的参数"><a href="#课堂练习：组件的参数" class="headerlink" title="课堂练习：组件的参数"></a>课堂练习：组件的参数</h2><p>组件可以从外部传入参数，内部使用<code>this.props</code>获取参数。</p>
<p>打开<code>demos/react-component-demo/index2.html</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#react-组件的参数" target="_blank" rel="external">《操作说明》</a>，完成练习。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span></span></span></div><div class="line">      <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> <span class="attr">this.props.color</span>&#125;&#125;</div><div class="line">    &gt;Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">MyTitle</span> <span class="attr">color</span>=<span class="string">"red"</span> /&gt;</span>,</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="示例：组件的状态"><a href="#示例：组件的状态" class="headerlink" title="示例：组件的状态"></a>示例：组件的状态</h2><p>组件往往会有内部状态，使用<code>this.state</code>表示。</p>
<p>浏览器打开<code>demos/react-component-demo/index3.html</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#react-组件的状态" target="_blank" rel="external">《操作说明》</a>，仔细查看源码。</p>
<p><img src="/assets/blogImg/react-component-state.png" alt=""></p>
<hr>
<h2 id="课堂练习：React-组件实战"><a href="#课堂练习：React-组件实战" class="headerlink" title="课堂练习：React 组件实战"></a>课堂练习：React 组件实战</h2><p>浏览器打开<code>demos/react-component-demo/index4.html</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#react-组件实战" target="_blank" rel="external">《操作说明》</a>，完成练习。</p>
<hr>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 为组件的不同生命阶段，提供了近十个钩子方法。</p>
<ul>
<li><code>componentWillMount()</code>：组件加载前调用</li>
<li><code>componentDidMount()</code>：组件加载后调用</li>
<li><code>componentWillUpdate()</code>: 组件更新前调用</li>
<li><code>componentDidUpdate()</code>: 组件更新后调用</li>
<li><code>componentWillUnmount()</code>：组件卸载前调用</li>
<li><code>componentWillReceiveProps()</code>：组件接受新的参数时调用</li>
</ul>
<p>我们可以利用这些钩子，自动完成一些操作。</p>
<hr>
<h2 id="课堂练习：组件的生命周期"><a href="#课堂练习：组件的生命周期" class="headerlink" title="课堂练习：组件的生命周期"></a>课堂练习：组件的生命周期</h2><p>组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在<code>componentDidMount</code>方法里面发出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">  <span class="keyword">const</span> url = <span class="string">'...'</span>;</div><div class="line">  $.getJSON(url)</div><div class="line">    .done()</div><div class="line">    .fail();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打开<code>demos/react-lifecycle-demo/index.html</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#react-组件的生命周期" target="_blank" rel="external">《操作说明》</a>，完成练习。</p>
<hr>
<h2 id="React-组件库"><a href="#React-组件库" class="headerlink" title="React 组件库"></a>React 组件库</h2><p>React 的一大优势，就是网上有很多已经写好的组件库，可以使用。</p>
<p>React-Bootstrap：<a href="https://react-bootstrap.github.io/" target="_blank" rel="external">https://react-bootstrap.github.io/</a></p>
<p><img src="/assets/blogImg/react-bootstrap.png" alt=""></p>
<hr>
<h2 id="示例：ReCharts"><a href="#示例：ReCharts" class="headerlink" title="示例：ReCharts"></a>示例：ReCharts</h2><p>ReCharts 是一个 React 图表组件库。<a href="http://recharts.org/" target="_blank" rel="external">http://recharts.org/</a></p>
<p>浏览器打开<code>demos/recharts-demo/index.html</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#recharts" target="_blank" rel="external">《操作说明》</a>，仔细查看源码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LineChart</span> <span class="attr">width</span>=<span class="string">&#123;1000&#125;</span> <span class="attr">height</span>=<span class="string">&#123;400&#125;</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">XAxis</span> <span class="attr">dataKey</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">YAxis</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">CartesianGrid</span> <span class="attr">stroke</span>=<span class="string">"#eee"</span> <span class="attr">strokeDasharray</span>=<span class="string">"5 5"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"uv"</span> <span class="attr">stroke</span>=<span class="string">"#8884d8"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"pv"</span> <span class="attr">stroke</span>=<span class="string">"#82ca9d"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">LineChart</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="React-的核心思想"><a href="#React-的核心思想" class="headerlink" title="React 的核心思想"></a>React 的核心思想</h2><p>View 是 State 的输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view = f(state)</div></pre></td></tr></table></figure>
<p>只要 State 发生变化，View 也要随之变化。</p>
<hr>
<p>React 的本质是将图形界面（GUI）函数化。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const person = &#123;</div><div class="line">  name: "michel",</div><div class="line">  age: 31</div><div class="line">&#125;</div><div class="line"></div><div class="line">const App = (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;</div><div class="line"></div><div class="line">ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body)</div></pre></td></tr></table></figure>
<hr>
<h2 id="React-应用的架构"><a href="#React-应用的架构" class="headerlink" title="React 应用的架构"></a>React 应用的架构</h2><p>React 只是一个 DOM 的抽象层，并没有解决应用程序的架构问题：大型应用程序应该如何组织代码？</p>
<p>Facebook 提出 Flux 架构的概念。</p>
<p><img src="/assets/blogImg/flow.png" alt=""></p>
<p>最大特点：数据单向流动</p>
<hr>
<h2 id="目前最流行的两个-React-架构"><a href="#目前最流行的两个-React-架构" class="headerlink" title="目前最流行的两个 React 架构"></a>目前最流行的两个 React 架构</h2><p>React 架构的最重要作用：管理 Store 与 View 之间的关系。</p>
<ul>
<li>MobX：响应式（Reative）管理，state 是可变对象，适合中小型项目</li>
<li>Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目</li>
</ul>
<hr>
<h2 id="MobX-架构"><a href="#MobX-架构" class="headerlink" title="MobX 架构"></a>MobX 架构</h2><p>MobX 的核心是观察者模式。</p>
<ul>
<li>Store 是被观察者（observable）</li>
<li>组件是观察者（observer）</li>
</ul>
<p>一旦<code>Store</code>有变化，会立刻被组件观察到，从而引发重新渲染。</p>
<hr>
<h2 id="MobX-的最简单例子"><a href="#MobX-的最简单例子" class="headerlink" title="MobX 的最简单例子"></a>MobX 的最简单例子</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const &#123;observable, computed&#125; = mobx;</div><div class="line">const &#123;observer&#125; = mobxReact;</div><div class="line"></div><div class="line">const person = observable(&#123;name: "张三", age: 31&#125;);</div><div class="line"></div><div class="line">const App = observer(</div><div class="line">  (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;</div><div class="line">);</div><div class="line"></div><div class="line">ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);</div><div class="line">person.name = "李四";</div></pre></td></tr></table></figure>
<p>代码：<code>demos/mobx-demo/browser-demo</code>目录</p>
<hr>
<h2 id="示例：MobX"><a href="#示例：MobX" class="headerlink" title="示例：MobX"></a>示例：MobX</h2><p>进入<code>demos/mobx-demo</code>目录，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#mobx" target="_blank" rel="external">《操作说明》</a>，理解 MobX 框架。</p>
<hr>
<p>UI 层是观察者，Store 是被观察者。</p>
<p>Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</div><div class="line">  @observable name = <span class="string">'Bartek'</span>;</div><div class="line">  @computed get decorated() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is awesome!`</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>UI 会观察到 Store 的变化，自动重新渲染。</p>
<hr>
<h2 id="Redux-架构"><a href="#Redux-架构" class="headerlink" title="Redux 架构"></a>Redux 架构</h2><p>Redux 的核心概念</p>
<ul>
<li>所有的状态存放在<code>Store</code>。组件每次重新渲染，都必须由状态变化引起。</li>
<li>用户在 UI 上发出<code>action</code>。</li>
<li><code>reducer</code>函数接收<code>action</code>，然后根据当前的<code>state</code>，计算出新的<code>state</code>。</li>
</ul>
<p><img src="/assets/blogImg/redux-architecture.png" alt=""></p>
<hr>
<h2 id="示例：Redux"><a href="#示例：Redux" class="headerlink" title="示例：Redux"></a>示例：Redux</h2><p>进入<code>demos/redux-demo</code>目录，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#redux" target="_blank" rel="external">《操作说明》</a>，理解 Redux 框架。</p>
<hr>
<ul>
<li>Redux 将组件分成 UI 组件和容器组件两类。</li>
<li>UI 组件是纯组件，需要用户自己写。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div className=<span class="string">"index"</span>&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.text&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line">  &lt;input</div><div class="line">    defaultValue=&#123;<span class="keyword">this</span>.props.name&#125;</div><div class="line">    onChange=&#123;<span class="keyword">this</span>.props.onChange&#125;</div><div class="line">  /&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<hr>
<p>容器组件在用户给出配置以后，由 Redux 生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// MyComponent 是纯的 UI 组件</div><div class="line">const App = connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(MyComponent);</div></pre></td></tr></table></figure>
<ul>
<li>mapStateToProps: 定义 UI 组件参数与 State 之间的映射</li>
<li>mapDispatchToProps：定义 UI 组件与 Action 之间的映射</li>
</ul>
<hr>
<p><code>reducer</code>是一个纯函数，用来接收<code>action</code>，算出新的<code>state</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;</span></span></div><div class="line">  text: <span class="string">'你好，访问者'</span>,</div><div class="line">  name: <span class="string">'访问者'</span></div><div class="line">&#125;, action) &#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>: action.payload,</div><div class="line">        <span class="attr">text</span>: <span class="string">'你好，'</span> + action.payload</div><div class="line">      &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>Store</code>由 Redux 提供的<code>createStore</code>方法生成，该方法接受<code>reducer</code>作为参数。</li>
<li>为了把<code>Store</code>传入组件，必须使用 Redux 提供的<code>Provider</code>组件在应用的最外面，包裹一层。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = createStore(reducer);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</div><div class="line">);</div></pre></td></tr></table></figure>
<h1 id="Node-应用开发"><a href="#Node-应用开发" class="headerlink" title="Node 应用开发"></a>Node 应用开发</h1><hr>
<h2 id="Node-简介"><a href="#Node-简介" class="headerlink" title="Node 简介"></a>Node 简介</h2><p>Node 是服务器的 JavaScript 运行环境，提供 API 与操作系统互动。</p>
<p>主要用途：</p>
<ul>
<li>开发前端应用</li>
<li>快速搭建服务</li>
<li>架设网站</li>
</ul>
<hr>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>安装 Node 的时候，会同时安装 npm。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm -v</div></pre></td></tr></table></figure>
<p>它是 Node 的模块管理器，开发 Node 项目的必备工具。</p>
<hr>
<h2 id="课堂练习：Node-的简单应用"><a href="#课堂练习：Node-的简单应用" class="headerlink" title="课堂练习：Node 的简单应用"></a>课堂练习：Node 的简单应用</h2><p>进入<code>demos/simple-app-demo</code>目录，参考<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#simple-app" target="_blank" rel="external">《操作指南》</a>，自己动手在 Node 里面，编写并编译一个前端脚本。</p>
<hr>
<h2 id="Node-开发前端脚本的好处"><a href="#Node-开发前端脚本的好处" class="headerlink" title="Node 开发前端脚本的好处"></a>Node 开发前端脚本的好处</h2><ol>
<li>模块机制</li>
<li>版本管理</li>
<li>对外发布</li>
<li>持续集成的标准开发流程</li>
</ol>
<hr>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>REST 是浏览器与服务器通信方式的一种设计风格。</p>
<p>它的全称是“REpresentational State Transfer”，中文意为”表现层状态转换“。</p>
<ul>
<li>Resource：资源</li>
<li>Representation：表现层</li>
<li>State：状态</li>
<li>Transfer：转换</li>
</ul>
<hr>
<h2 id="REST-的核心概念"><a href="#REST-的核心概念" class="headerlink" title="REST 的核心概念"></a>REST 的核心概念</h2><ol>
<li>互联网上所有可以访问的内容，都是资源。</li>
<li>服务器保存资源，客户端请求资源。</li>
<li>同一个资源，有多种表现形式。</li>
<li>协议本身不带有状态，通信时客户端必须通过参数，表示请求不同状态的资源。</li>
<li>状态转换通过HTTP动词表示。</li>
</ol>
<hr>
<h2 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h2><p>URL 是资源的唯一识别符。</p>
<ul>
<li>/store/1</li>
<li>/store/2</li>
<li>/store/1/employee/2</li>
</ul>
<hr>
<h2 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h2><p>查询字符串表示对所请求资源的约束条件。</p>
<ul>
<li>GET /zoos/1/animals?limit=10</li>
<li>GET /zoos/1/animals?limit=10&amp;offset=10</li>
<li>GET /animals?zoo_id=1</li>
</ul>
<hr>
<h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><table>
<thead>
<tr>
<th>操作</th>
<th>SQL方法</th>
<th>HTTP动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>INSERT</td>
<td>POST</td>
</tr>
<tr>
<td>READ</td>
<td>SELECT</td>
<td>GET</td>
</tr>
<tr>
<td>UPDATE</td>
<td>UPDATE</td>
<td>PUT/PATCH</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">GET</span> /<span class="built_in">v1</span>/stores/<span class="number">1234</span></div><div class="line"><span class="symbol">PUT</span> /<span class="built_in">v1</span>/stores/<span class="number">1234</span></div><div class="line"><span class="symbol">POST</span> /<span class="built_in">v1</span>/stores</div><div class="line"><span class="symbol">DELETE</span> /<span class="built_in">v1</span>/stores/<span class="number">1234</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="课堂练习：REST-API"><a href="#课堂练习：REST-API" class="headerlink" title="课堂练习：REST API"></a>课堂练习：REST API</h2><p>打开<code>demos/rest-api-demo</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#rest-api" target="_blank" rel="external">《操作指南》</a>，熟悉 REST API 的基本用法。</p>
<hr>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>Express 是最常用的 Node 框架，用来搭建 Web 应用。</p>
<p><img src="/assets/blogImg/express.png" alt=""></p>
<hr>
<h2 id="课堂练习：Express-搭建-Web-应用"><a href="#课堂练习：Express-搭建-Web-应用" class="headerlink" title="课堂练习：Express 搭建 Web 应用"></a>课堂练习：Express 搭建 Web 应用</h2><p>进入<code>demos/express-demo</code>目录，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#express" target="_blank" rel="external">《操作指南》</a>，学习使用 Express 搭建 Web 应用。</p>
<hr>
<p>定义一个 Web 应用实例，并且启动它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express    = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> app        = express();</div><div class="line"></div><div class="line"><span class="keyword">var</span> port = process.env.PORT || <span class="number">8080</span>;</div><div class="line"></div><div class="line">app.listen(port);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Magic happens on port '</span> + port);</div></pre></td></tr></table></figure>
<hr>
<p>定义一个路由</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> router = express.Router();</div><div class="line"></div><div class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'&lt;h1&gt;Hello World&lt;/h1&gt;'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.use(<span class="string">'/home'</span>, router);</div></pre></td></tr></table></figure>
<hr>
<p>中间件：对 HTTP 请求进行加工。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'There is a requesting.'</span>);</div><div class="line">  next();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="前端工程简介"><a href="#前端工程简介" class="headerlink" title="前端工程简介"></a>前端工程简介</h1><hr>
<h2 id="持续集成流程"><a href="#持续集成流程" class="headerlink" title="持续集成流程"></a>持续集成流程</h2><p>前端开发转移到后端环境，意味着可以适用标准的软件工程流程。</p>
<ol>
<li>本地开发（developing）</li>
<li>静态代码检查（linting）</li>
<li>单元测试（testing）</li>
<li>合并进入主干（merging）</li>
<li>自动构建（building）</li>
<li>自动发布（publishing）</li>
</ol>
<hr>
<h2 id="持续集成的概念"><a href="#持续集成的概念" class="headerlink" title="持续集成的概念"></a>持续集成的概念</h2><p>Continuous integration（简称 CI）：</p>
<p>开发代码频繁地合并进主干，始终保持可发布状态的这个过程。</p>
<p>优点</p>
<ul>
<li>快速发现错误</li>
<li>防止分支大幅偏离主干</li>
<li>让产品可以快速迭代，同时还能保持高质量</li>
</ul>
<hr>
<h2 id="ESLint：静态代码检查工具"><a href="#ESLint：静态代码检查工具" class="headerlink" title="ESLint：静态代码检查工具"></a>ESLint：静态代码检查工具</h2><ul>
<li>发现语法错误</li>
<li>发现风格错误</li>
<li>自动纠正错误</li>
</ul>
<p><img src="/assets/blogImg/eslint.png" alt=""></p>
<hr>
<h2 id="课堂练习：ESLint-的用法"><a href="#课堂练习：ESLint-的用法" class="headerlink" title="课堂练习：ESLint 的用法"></a>课堂练习：ESLint 的用法</h2><p>进入<code>demos/eslint-demo</code>目录，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#eslint" target="_blank" rel="external">《操作指南》</a>，完成练习。</p>
<hr>
<h2 id="为什么写测试？"><a href="#为什么写测试？" class="headerlink" title="为什么写测试？"></a>为什么写测试？</h2><p>Web 应用越来越复杂，意味着更可能出错。测试是提高代码质量、降低错误的最好方法之一。</p>
<ul>
<li>测试可以确保得到预期结果。</li>
<li>加快开发速度。</li>
<li>方便维护。</li>
<li>提供用法的文档。</li>
</ul>
<p>对于长期维护的项目，测试可以减少投入时间，减轻维护难度。</p>
<hr>
<h2 id="测试的类型"><a href="#测试的类型" class="headerlink" title="测试的类型"></a>测试的类型</h2><ul>
<li>单元测试（unit testing）</li>
<li>功能测试（feature testing）</li>
<li>集成测试（integration testing）</li>
<li>端对端测试 (End-to-End testing）</li>
</ul>
<hr>
<h2 id="以测试为导向的开发模式"><a href="#以测试为导向的开发模式" class="headerlink" title="以测试为导向的开发模式"></a>以测试为导向的开发模式</h2><ul>
<li>TDD：测试驱动的开发（Test-Driven Development）</li>
<li>BDD：行为驱动的开发（Behavior-Driven Development）</li>
</ul>
<p>它们都要求先写测试，再写代码。</p>
<p>思考题：测试导向的开发模式有明显的优点，为什么现实生活中采用的人不多？</p>
<hr>
<h2 id="TDD-vs-BDD"><a href="#TDD-vs-BDD" class="headerlink" title="TDD vs. BDD"></a>TDD vs. BDD</h2><p>两者侧重点不一样</p>
<ul>
<li>TDD：基于开发者角度，重点测试函数的输入输出</li>
<li>BDD：基于使用者角度，重点测试对用户行为的反应</li>
</ul>
<p>比如，有一个计数器函数<code>counter</code>，TDD 测试的是输入1，输出的应该是2；BDD 测试的是用户访问以后，计数器应该增加一次。</p>
<hr>
<h2 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h2><p>Mocha 是目前最常用的测试框架。</p>
<p><img src="/assets/blogImg/mocha.png" alt=""></p>
<hr>
<h2 id="课堂练习：Mocha-的用法"><a href="#课堂练习：Mocha-的用法" class="headerlink" title="课堂练习：Mocha 的用法"></a>课堂练习：Mocha 的用法</h2><p>进入<code>demos/mocha-demo</code>目录，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#mocha" target="_blank" rel="external">《操作指南》</a>，练习写单元测试。</p>
<hr>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>功能测试指的是，站在外部用户的角度，测试软件的某项功能。</p>
<p>与内部代码实现无关，只测试功能是否正常。</p>
<p>很多时候，单元测试都可以通过，但是整体功能会失败。</p>
<p><img src="/assets/blogImg/functional-test.jpg" alt=""></p>
<hr>
<h2 id="前端的功能测试"><a href="#前端的功能测试" class="headerlink" title="前端的功能测试"></a>前端的功能测试</h2><p>功能测试必须在真正浏览器做，现在有四种方法。</p>
<ul>
<li>使用本机安装的浏览器</li>
<li>使用 Selenium Driver</li>
<li>使用 PhantomJS</li>
<li>使用 Electron</li>
</ul>
<hr>
<h2 id="Nightmare"><a href="#Nightmare" class="headerlink" title="Nightmare"></a>Nightmare</h2><ul>
<li>使用 Electron 模拟真实浏览器环境</li>
<li>提供大量人性化、易用的 API</li>
<li>官网：nightmarejs.org</li>
</ul>
<hr>
<h2 id="示例：Nightmare"><a href="#示例：Nightmare" class="headerlink" title="示例：Nightmare"></a>示例：Nightmare</h2><p>打开<code>demos/nightmare-demo/</code>，按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#nightmare" target="_blank" rel="external">《操作说明》</a>，完成操作。</p>
<hr>
<h2 id="移动平台的自动化测试"><a href="#移动平台的自动化测试" class="headerlink" title="移动平台的自动化测试"></a>移动平台的自动化测试</h2><p>目前，最常见的方案是使用 Appium。</p>
<ul>
<li>基于 WebDriver</li>
<li>采用 客户端/服务器架构</li>
<li>可以在模拟器运行，也可以在真机运行</li>
</ul>
<hr>
<h2 id="Appium-测试流程"><a href="#Appium-测试流程" class="headerlink" title="Appium 测试流程"></a>Appium 测试流程</h2><ol>
<li>WebDriver 客户端发出测试请求和测试内容</li>
<li>Appium 服务器转发到相应的测试运行器（Driver）</li>
<li>iOS 设备是 UIAutomation，安卓设备是 UiAutomator</li>
<li>测试运行器将运行结果，返回给 Appium</li>
</ol>
<hr>
<h2 id="持续集成服务平台"><a href="#持续集成服务平台" class="headerlink" title="持续集成服务平台"></a>持续集成服务平台</h2><p>代码合并进主干以后，就可以进行自动构建和发布了。</p>
<p>网上有很多 PaaS 平台，提供持续集成服务。</p>
<p>Travis CI 就是其中最著名的一个，它可以根据你提供的脚本，自动完成构建和发布。</p>
<p><img src="/assets/blogImg/travis-ci.png" alt=""></p>
<hr>
<h2 id="课堂练习：Travis-CI"><a href="#课堂练习：Travis-CI" class="headerlink" title="课堂练习：Travis CI"></a>课堂练习：Travis CI</h2><p>按照<a href="https://github.com/ruanyf/jstraining/tree/master/demos/README.md#travis-ci" target="_blank" rel="external">《操作说明》</a>，完成练习。</p>
<p>所有内容都配有 Demo 和操作指导，帮助读者边学边练，保证学会。</p>
<p><img src="/assets/blogImg/bg2016111502.png" alt=""></p>
<p>我已经找了一个场合，试讲了一次上面的内容，觉得效果还可以。<br>本教程采用 GPL 许可证，你可以自由地使用它，唯一的条件是如果对内容做出任何改进，你也必须在 GPL 许可证下开源。<br>我也接受现场培训。如果你们公司有这个需要，可以联系我。不过，讲课费比较贵，所以还是推荐大家自学。<br>（完）</p>
<hr>
<p>以上内容全都转自阮一峰博客，自由转载非商用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/fullstack.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;JavaScript 全栈工程师培训教程&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>游戏纯属爱好</title>
    <link href="http://yoursite.com/2016/12/09/zwh6/"/>
    <id>http://yoursite.com/2016/12/09/zwh6/</id>
    <published>2016-12-09T07:28:00.000Z</published>
    <updated>2016-12-09T08:28:17.255Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/elin1.png" alt=""></p>
<p>&emsp;&emsp;小的时候玩什么？2007年我才学会自己申请QQ，那时候记性不好，还把QQ号写在纸上，去网吧的时候，老是揣个小纸条儿。<br><a id="more"></a><br>&emsp;&emsp;QQ差不多玩儿了一年多不知不觉就记住了，不可否认的说，那时候确实沉迷游戏，小游戏玩小霸王游戏机的超级玛丽，大游戏到Ps4的铁拳，那时候去网吧简直就是一种奢华，平时都是玩儿街机，就投币那种，一块钱10个币，后来玩的多了，就开始联机玩儿GTA和一些主流的单机盗版游戏，什么单机CF，单机DNF就没有不玩儿的，每天10块钱的零花钱，全都省吃俭用的留下来，买盗版光碟，装单机游戏玩儿，就随便一个游戏能玩儿好几个月，下面来介绍一下我玩儿过的感觉比较经典的单机游戏</p>
<p>1.真三国无双</p>
<p><img src="/assets/blogImg/lvbu.png" alt=""></p>
<p>那时候是我第一次接触到这种日本制作的三国题材的大型单机游戏，当时用的配的垃圾联想电脑，集成显卡，G610，也就只能玩玩这种低端的，配置要求不是很高。</p>
<p>2.GTA 圣安地列斯</p>
<p>神龙</p>
<p><img src="/assets/blogImg/long2.png" alt=""></p>
<p>控制汽车</p>
<p><img src="/assets/blogImg/texiao1.png" alt=""></p>
<p>杰森和布莱迪</p>
<p><img src="/assets/blogImg/bulaidi.png" alt=""></p>
<p>外星人国度</p>
<p><img src="/assets/blogImg/waixin.png" alt=""></p>
<p>王尼玛</p>
<p><img src="/assets/blogImg/wangnima.png" alt=""></p>
<p>假面骑士</p>
<p><img src="/assets/blogImg/jiamian.png" alt=""></p>
<p>核弹</p>
<p><img src="/assets/blogImg/hedan.png" alt=""></p>
<p>岛屿</p>
<p><img src="/assets/blogImg/daoyu.png" alt=""></p>
<p>总的来说GTA真是帅，真是神，啥都能改，啥都能做，属于一个高度自由的可编辑单机游戏<br>，凡是你觉得有意思的东西都可以弄到游戏里面来玩儿，可联机可单机，上可九天揽月，下可五洋捉鳖，可能大家看我说的这么牛逼，就想说，你咋不上天呢？恩，没错，这游戏确实可以送你上天</p>
<p><img src="/assets/blogImg/shangtian.png" alt=""></p>
<p><img src="/assets/blogImg/shangtian2.png" alt=""></p>
<p>最后帖上一张我大GTA5的model龙图</p>
<p><img src="/assets/blogImg/long.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/elin1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;小的时候玩什么？2007年我才学会自己申请QQ，那时候记性不好，还把QQ号写在纸上，去网吧的时候，老是揣个小纸条儿。&lt;br&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>你死了之后，身体会怎么样？</title>
    <link href="http://yoursite.com/2016/12/09/zwh5/"/>
    <id>http://yoursite.com/2016/12/09/zwh5/</id>
    <published>2016-12-09T07:22:00.000Z</published>
    <updated>2016-12-13T06:12:20.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/die.png" alt=""><br>死后之谜</p>
<a id="more"></a>
<embed height="700" width="850" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=6999879&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash">
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/die.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;死后之谜&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>灾难电影——隧道</title>
    <link href="http://yoursite.com/2016/12/09/zwh4/"/>
    <id>http://yoursite.com/2016/12/09/zwh4/</id>
    <published>2016-12-09T02:36:00.000Z</published>
    <updated>2016-12-13T01:45:59.712Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/suidao.jpg" alt=""><br>灾难面前，生命如此卑微，如此渺小，政府的漠视，终究还是信念和坚守打败了一切~</p>
<a id="more"></a>
<embed height="700" width="850" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=6270550&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash">
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/suidao.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;灾难面前，生命如此卑微，如此渺小，政府的漠视，终究还是信念和坚守打败了一切~&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>为什么人的脚为什么比人的脸和手都要白呢？因为它老藏着。</title>
    <link href="http://yoursite.com/2016/12/07/zwh3/"/>
    <id>http://yoursite.com/2016/12/07/zwh3/</id>
    <published>2016-12-07T10:36:00.000Z</published>
    <updated>2016-12-09T07:22:33.557Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/caocao1.png" alt=""></p>
<p>一生中最佩服的历史人物司马懿，懂得忍辱负重，待时而起的大才之人。</p>
<a id="more"></a>
<p><img src="/assets/blogImg/sima1.png" alt=""><br><img src="/assets/blogImg/sima2.png" alt=""><br><img src="/assets/blogImg/sima3.png" alt=""><br><img src="/assets/blogImg/sima4.png" alt=""><br><img src="/assets/blogImg/sima5.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/caocao1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一生中最佩服的历史人物司马懿，懂得忍辱负重，待时而起的大才之人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title> 今年我给自己定了三个目标</title>
    <link href="http://yoursite.com/2016/12/07/zwh2/"/>
    <id>http://yoursite.com/2016/12/07/zwh2/</id>
    <published>2016-12-07T09:42:00.000Z</published>
    <updated>2016-12-08T02:04:47.976Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/blog-7.png" alt=""><br>生于忧患死于安乐，要想在这看似动荡浮躁的时代安身立命唯有找一份事业,认真踏实去干; 一直干到如同庖丁解牛的境界。 这样，身也安了,命也立了。 就是这样。<br><a id="more"></a><br>1.学会并使用web三大框架(React.js、Vue.js、AngularJs)增加知识面</p>
<p><img src="/assets/blogImg/blog-4.png" alt=""></p>
<p><img src="/assets/blogImg/blog-3.png" alt=""></p>
<p>2.搞定英语三级课程<br><img src="/assets/blogImg/blog-5.png" alt=""> </p>
<p>3.在高新区找一份新工作<br><img src="/assets/blogImg/blog-6.png" alt=""></p>
<p>箭在弦上，不得不发。</p>
<p><img src="/assets/blogImg/blog-2.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/blog-7.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;生于忧患死于安乐，要想在这看似动荡浮躁的时代安身立命唯有找一份事业,认真踏实去干; 一直干到如同庖丁解牛的境界。 这样，身也安了,命也立了。 就是这样。&lt;br&gt;
    
    </summary>
    
    
      <category term="目标" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title> 2016年我第一次写博客</title>
    <link href="http://yoursite.com/2016/12/06/zwh1/"/>
    <id>http://yoursite.com/2016/12/06/zwh1/</id>
    <published>2016-12-06T07:29:00.000Z</published>
    <updated>2016-12-07T09:47:15.815Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/blog-1.png" alt=""><br>&emsp;&emsp;小时候呢总想看看20岁的自己到底会变成什么样子，那时候哪会想到如今的自己居然是个碌碌无为的程序员，怪命运？还是自己？现在的我只想要过好当下的每一秒，哪怕是呼吸的那一秒，也要好好珍惜，因为我深知如今的我不可以再像从前了，这里引用我曾经看到过的一句话，人一旦看到真相了，就很难再闭上眼睛假装不知道。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/blog-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;小时候呢总想看看20岁的自己到底会变成什么样子，那时候哪会想到如今的自己居然是个碌碌无为的程序员，怪命运？还是自己？现在的我只想要过好当下的每一秒，哪怕
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
