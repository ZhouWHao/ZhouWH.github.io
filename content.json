[{"title":"你觉得和珅是好官还是贪官？","date":"2016-12-23T03:00:00.000Z","path":"2016/12/23/zwh10/","text":"&emsp;&emsp;行行行，君忠我奸，君廉我贪，君贤我恶，嗯，行吧，天下清名被你占光，天下恶名被我占光。那你我岂能不饮上一杯？","tags":[{"name":"电视剧","slug":"电视剧","permalink":"http://yoursite.com/tags/电视剧/"}]},{"title":"前端模块化这几年太先进，先进得我都不认识它了","date":"2016-12-10T02:33:00.000Z","path":"2016/12/10/zwh9/","text":"&emsp;&emsp; 一、什么是模块？定义：具有相同属性和行为的事物的集合 在前端中：将一些属性比较类似和行为比较类似的内容放在同一个js文件里面，把这个js文件称为模块 目的：为了每个js文件只关注与自身有关的事情，让每个js文件各行其职 二、什么是模块化？CommonJS是什么？AMD和CMD又是什么？①模块化：指的就是遵守commonjs规范，解决不同js模块之间相互调用问题 ②CommonJS： 1. A.js文件中调用另一个B.js文件，一定要在A.js中引入B.js 1require(\"B.js\"); 2. 另一个被调用的js，也就是B.js一定要对外提供接口。 1module.exports=B; 过程如下： B.js 123javascriptvar b = \"Hello,I'm module B.\";module.exports = b;//暴露一个接口，与b对接。这个接口既可以是函数，也可以是对象，甚至是数组。 A.js 1234javascriptvar _b = require(\"./B.js\");//实际过程中应当是B.js相对于A.js的路径，这比使用绝对路径去获取要规范得多//此时_b获得了B.js的接口，这个接口指向B.js中的变量bconsole.log( _b );//\"Hello,I'm module B.\"; 这就实现了一个简单的模块化工作方式，即： 模块间相互调用，协同工作，实现某特定功能。 ④AMD规范：Async Module Define 异步模块声明 ⑤CMD规范：Common Module Define 公共模块声明 ⑥模块化的核心价值：模块化最核心的价值在于解决不同文件之间的分工和调用问题，即依赖关系。 三、模块化的一些工具 gulp + browerify 构建步骤： 1. 安装gulp 1npm install gulp --save-dev //要安装全局还是本地依赖根据实际情况来 2. 安装browserify –save–dev 1npm install browserify --save--dev 3. 安装文件输出流工具 1npm install vinyl-source-stream --save-dev 4. 在gulpfile里编写任务实现模块化 gulpfile.js 12345678910111213//基本模块引入var gulp = require('gulp');var brow = require('browerify');var source = require('vinyl-source-stream');//任务编写gulp.task('bundle', function() &#123;//将任务交付给browserify//brow读取入口文件后，能自动查找相互之间有依赖的关系的模块 return brow('./entry.js') .bundle()//输出一个文件流变量（gulp的工作机制） .pipe(source('bundle.js'))//将文件流变量输出为文件 .pipe(gulp.dest('js'));//将文件最终输出&#125; webpack 参考[webpack的配置及使用][1] requireJS 模块声明规范：AMD 声明模块 参数1：id 是这个模块的名称，它是一个可选参数，默认为require加载此模块时指定的名称，若定义这个参数，那么这个模块名应当为“顶级”的，不允许相对名称。 参数2：数组，为这个模块所依赖的其他模块 匿名函数参数：为依赖模块在这个模块中的接口，它们是一一对应的，因此即便不需要某个模块的接口，但若是需要它后面模块的接口，那也必须给它增加一个用于占位的参数。 1234567define( 'id', [ 'module1', 'module2' ], function( m1, m2 ) &#123; return &#123; arg1: m1, arg2: m2 &#125; //返回值即是module3的接口&#125;); 使用步骤 1. 下载requireJS 1bower install requirejs//根据个人习惯选择下载方式，只要保证后续引入的路径正确 2. 配置config文件和main.js config.js 1234567require.config( &#123; base: '',//引入模块的起始路径 //paths对象为要引入的模块的名称及路径，且不需.js后缀，require默认会为文件添加.js后缀 paths: &#123; 'jquery': './jquery-1.11.0'//这就引入了juery作为一个模块。 PS：jquery自己已经实现了AMD，并且'jquery'是一个顶级模块名。 &#125;&#125; ); main.js 123require(['jquery'], function( $ ) &#123; $(document).css(\"background\", \"#000\");//这就实现了引入使用jquery模块，并用它进行dom操作&#125;); 3. 在页面中引入 12&lt;script data-main=\"./main.js\" src=\"./bower-components/requirejs/dist/require.js&gt;&lt;/script&gt;//main即是主逻辑入口文件 SeaJS 模块声明规范：CMD 声明模块 1234define( function( require, exports, module ) &#123; var c = require('./Controller.js'); c();&#125;) 使用步骤 1. 下载seajs 1bower install seajs//这里根据个人习惯下载seajs的包，只要引入时路径正确就行 2. 配置seajs.config 1234seajs.config(&#123; base: './', //模块起始路径&#125;)seajs.use('./main');//使用主逻辑入口文件，相当于requirejs中的data-main文件 requireJS和SeaJS都是在前端实现模块化，相当于一个前端的js模块化加载器，和webpack不一样，webpack是通过nodejs将文件打包的。 四、模块化案例前端mvc架构 Vue 组件化&amp;模块化 React 组件化&amp;模块化 node.js 每个文件都是模块 什么是MVC 后端开发的一种概念 即view( html + js + css + img ) + controller( 控制层 ) + model( 数据模型 ) 前端演变了一套MVC体系： veiw( html + css + js ) 写静态页面 css、js、img及效果 controller( 专注于实现服务和逻辑控制的层面叫做控制器 ) 监听页面中请求和事件，处理请求和事件；向model请求数据，得到数据后绑定到页面 model ( 数据变量 || ajax从服务端取回的数据 ) 对外提供一些数据 体现了一种分层的概念，让每个层面只做自己该做的行为，减少代码耦合和冗余 为什么使用MVC？ 低耦合： MVC将业务分为三层，减少了数据与业务的耦合性，增强了各层次功能的独立性，使得在需求改变时可能只需要改变其中一层就能完成服务； 复用性高： 三层业务功能分明，耦合度低，使各模块可以独立完成自身功能，降低了依赖性，具有很高的复用性。 利于批量生产和扩展： 复用性高使得在批量生产的时候可以根据需求进行模块的重用，加快了生产效率。并且模块化使得扩展也非常方便，模块只需根据规范进行编写，经审核后引入便可以实现扩展。 利于协作开发： 扩展性强使协作开发也变得非常方便，每个人根据自己的分工设计自己的模块，不与他人冲突，引入时也各行其职。 推广普及度高： 由于对协作开发的友好，使得MVC模式大受开发者的欢迎，使用这个模式的产品的推广和普及变得容易得多。","tags":[{"name":"前端模块化管理","slug":"前端模块化管理","permalink":"http://yoursite.com/tags/前端模块化管理/"}]},{"title":"Javascript全栈之道","date":"2016-12-10T02:33:00.000Z","path":"2016/12/10/zwh7/","text":"JavaScript 全栈工程师培训教程 一、培训准备参加培训的学员，事先应该做好以下准备工作。 知识准备 掌握 HTML、CSS、JS 的基本用法 掌握命令行的基本用法安装 Git 请到官网 git-scm.com 或国内的下载站，下载安装包。 安装 Node请到 Node 官网nodejs.org，或者国内镜像npm.taobao.org/mirrors/node，下载安装包。推荐安装最新的稳定版，目前是v6.x。 安装完成后，命令行执行下面的命令，确认是否安装成功。 12$ node -vv6.9.1 Node 的模块管理器 npm 会一起安装好。由于 Node 的官方模块仓库网速太慢，模块仓库需要切换到阿里的源。 1$ npm config set registry https://registry.npm.taobao.org/ 执行下面的命令，确认是否切换成功。 1$ npm config get registry 安装 PostmanPostman 是一个 HTTP 通信测试工具，REST API 的练习会用到它。 请到官网 GetPostman.com 下载独立安装包；也可以参考这篇文章www.cnblogs.com/mafly/p/postman.html，下载 Chrome 浏览器的插件，它们的效果一样。 安装示例库所有的讲义和练习源码，都是开源的，网址是 github.com/ruanyf/jstraining。执行下面的命令，将这个库拷贝到你的硬盘上。 12345# Linux &amp; Mac$ git clone git@github.com:ruanyf/jstraining.git# Windows$ git clone https://github.com/ruanyf/jstraining.git 如果因为种种原因，Git 命令行无法使用，也可以直接下载压缩包，地址是 https://github.com/ruanyf/jstraining/archive/master.zip 。 二、前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行 前后端不分的时代互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。 后端收到浏览器的请求 生成静态页面 发送到浏览器 后端 MVC 的开发模式那时的网站开发，采用的是后端 MVC 模式。 Model（模型层）：提供/保存数据 Controller（控制层）：数据处理，实现业务逻辑 View（视图层）：展示数据，提供用户界面 前端只是后端 MVC 的 V。 以 PHP 框架 Laravel 为例。 前端工程师的角色那时的前端工程师，实际上是模板工程师，负责编写页面模板。 后端代码读取模板，替换变量，渲染出页面。 典型的 PHP 模板1234567891011&lt;html&gt; &lt;head&gt;&lt;title&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;Make: &#123;&#123; $car-&gt;make &#125;&#125;&lt;/li&gt; &lt;li&gt;Model: &#123;&#123; $car-&gt;model &#125;&#125;&lt;/li&gt; &lt;li&gt;Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;&lt;/li&gt;&lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; AjaxAjax 技术诞生，改变了一切。 2004年：Gmail 2005年：Google 地图 前端不再是后端的模板，可以独立得到各种数据。 Ajax 技术促成了 Web 2.0 的诞生。 web2.png Web 1.0：静态网页，纯内容展示 Web 2.0：动态网页，富交互，前端数据处理 从那时起，前端变得复杂了，对前端工程师的要求越来越高。 前端 MVC 框架 前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 2010年，Backbone.js Backbone.jsBackbone 将前端代码分成两个基本部分。 Model：管理数据 View：数据的展现 前端 ControllerBackbone 只有 M 和 V，没有 C。因为，前端 Controller 与后端不同。 不需要，也不应该处理业务逻辑 只需要处理 UI 逻辑，响应用户的一举一动 所以，前端 Controller 相对比较简单。Backbone 没有 C，只用事件来处理 UI 逻辑。 123456789101112 var AppView = Backbone.View.extend(&#123;// ...events: &#123; \"keypress #new-todo\": \"createOnEnter\", \"click #clear-completed\": \"clearCompleted\", \"click #toggle-all\": \"toggleAllComplete\"&#125;, &#125;); Router前端还有一种天然的方法，可以切换视图，那就是 URL。 通过 URL 切换视图，这就是 Router（路由）的作用。以 Backbone 为例。 123456789101112App.Router = Backbone.Router.extend(&#123; routes: &#123;'': 'index','show': 'show'&#125;, index: function () &#123;$(document.body).append(\"调用了 Index 路由\"); &#125;, show: function () &#123;$(document.body).append(\"调用了 Show 路由\"); &#125;,&#125;); 示例：Backbone Router打开demos/backbone-demo/index.html，按照《操作说明》，查看示例。 MVVM 模式另一些框架提出 MVVM 模式，用 View Model 代替 Controller。 Model View View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。 本质：view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。 SPA前端可以做到： 读写数据 切换视图 用户交互 这意味着，网页其实是一个应用程序。 SPA = Single-page application2010年后，前端工程师从开发页面，变成了开发”前端应用“（跑在浏览器里面的应用程序）。 AngularGoogle 公司推出的 Angular 是最流行的 MVVM 前端框架。 它的风格属于 HTML 语言的增强，核心概念是双向绑定。 示例：Angular 的双向绑定浏览器打开demos/angular-demo/index.html，可以看到一个输入框。 1234567891011&lt;div ng-app=\"\"&gt; &lt;p&gt;姓名 :&lt;input type=\"text\" ng-model=\"name\" placeholder=\"在这里输入您的大名\"&gt; &lt;/p&gt; &lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; VueVue.js 是现在很热门的一种前端 MVVM 框架。 它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。 示例：Vue 的双向绑定Vue 的模板与数据，是双向绑定的。 打开demos/vue-demo/index1.html，按照《操作说明》，查看示例。 HTML 代码 1234&lt;div id=\"journal\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; JS 代码 123456var journal = new Vue(&#123; el: '#journal', data: &#123;message: 'Your first entry' &#125;&#125;); 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。 REST 接口前后端分离以后，它们之间通过接口通信。 后端暴露出接口，前端消费后端提供的数据。 后端接口一般是 REST 形式，前后端的通信协议一般是 HTTP。 Node2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。 Node = JavaScript + 操作系统 API Node 的意义 JavaScript 成为服务器脚本语言，与 Python 和 Ruby 一样 JavaScript 成为唯一的浏览器和服务器都支持的语言 前端工程师可以编写后端程序了 前端开发模式的根本改变 Node 环境下开发 大量使用服务器端工具 引入持续集成等软件工程的标准流程 开发完成后，编译成浏览器可以运行的脚本，放上 CDN 全栈工程师前端工程师正在转变为全栈工程师 一个人负责开发前端和后端 从数据库到 UI 的所有开发 全栈技能怎样才能称为全栈工程师？ 传统前端技能：HTML、JavaScript、CSS 一门后端语言 移动端开发：iOS / Android / HTML5 其他技能：数据库、HTTP 等等 软件行业的发展动力历史演变：前后端不分 -&gt; 前后端分离 -&gt; 全栈工程师 动力：更加产业化、大规模地生产软件 效率更高 成本更低 通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高。 H5 就是一个最好的例子为什么 H5 技术会赢得移动端？ 开发速度快：Native 需要重新编译才能看到结果，H5 是即时输出 开发成本低：Native 需要两个开发团队，H5 只要一个 快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新 未来软件的特点 联网 高并发 分布式 跨终端现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。 未来只有两种软件工程师 端工程师 手机端 PC 端 TV 端 VR 端 …… 云工程师 React 技术栈 React 是目前最热门的前端框架。 Facebook 公司2013年推出 现在最好的社区支持和生态圈 大量的第三方工具 React 的优点 组件模式：代码复用和团队分工 虚拟 DOM：性能优势 移动端支持：跨终端 React 的缺点 学习曲线较陡峭 全新的一套概念，与其他所有框架截然不同 只有采用它的整个技术栈，才能发挥最大威力 总结：React 非常先进和强大，但是学习和实现成本都不低 JSX 语法React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。 1let myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;; JSX 语法解释（1）JSX 语法的最外层，只能有一个节点。 12// 错误let myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;; （2）JSX 语法中可以插入 JavaScript 代码，使用大括号。 1let myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt; Babel 转码器JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。 123456&lt;script src=\"react.js\"&gt;&lt;/script&gt;&lt;script src=\"react-dom.js\"&gt;&lt;/script&gt;&lt;script src=\"babel.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/babel\"&gt; // ** Our code goes here! **&lt;/script&gt; React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。 Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。 课堂练习：JSX 语法浏览器打开demos/jsx-demo/index.html，按照《操作说明》，完成练习。 1234ReactDOM.render( &lt;span&gt;Hello World!&lt;/span&gt;, document.getElementById('example')); 示例：React 组件React 允许用户定义自己的组件，插入网页。 浏览器打开demos/react-component-demo/index1.html，按照《操作说明》，仔细查看源码。 12345678910class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example')); 课堂练习：组件的参数组件可以从外部传入参数，内部使用this.props获取参数。 打开demos/react-component-demo/index2.html，按照《操作说明》，完成练习。 123456789class MyTitle extends React.Component &#123; render() &#123; return &lt;h1 style=&#123;&#123;color: this.props.color&#125;&#125; &gt;Hello World&lt;/h1&gt;; &#125;&#125;;&lt;MyTitle color=\"red\" /&gt;, 示例：组件的状态组件往往会有内部状态，使用this.state表示。 浏览器打开demos/react-component-demo/index3.html，按照《操作说明》，仔细查看源码。 课堂练习：React 组件实战浏览器打开demos/react-component-demo/index4.html，按照《操作说明》，完成练习。 组件的生命周期React 为组件的不同生命阶段，提供了近十个钩子方法。 componentWillMount()：组件加载前调用 componentDidMount()：组件加载后调用 componentWillUpdate(): 组件更新前调用 componentDidUpdate(): 组件更新后调用 componentWillUnmount()：组件卸载前调用 componentWillReceiveProps()：组件接受新的参数时调用 我们可以利用这些钩子，自动完成一些操作。 课堂练习：组件的生命周期组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在componentDidMount方法里面发出。 123456componentDidMount() &#123; const url = '...'; $.getJSON(url) .done() .fail();&#125; 打开demos/react-lifecycle-demo/index.html，按照《操作说明》，完成练习。 React 组件库React 的一大优势，就是网上有很多已经写好的组件库，可以使用。 React-Bootstrap：https://react-bootstrap.github.io/ 示例：ReChartsReCharts 是一个 React 图表组件库。http://recharts.org/ 浏览器打开demos/recharts-demo/index.html，按照《操作说明》，仔细查看源码。 1234567&lt;LineChart width=&#123;1000&#125; height=&#123;400&#125; data=&#123;data&#125;&gt; &lt;XAxis dataKey=\"name\"/&gt; &lt;YAxis/&gt; &lt;CartesianGrid stroke=\"#eee\" strokeDasharray=\"5 5\"/&gt; &lt;Line type=\"monotone\" dataKey=\"uv\" stroke=\"#8884d8\" /&gt; &lt;Line type=\"monotone\" dataKey=\"pv\" stroke=\"#82ca9d\" /&gt;&lt;/LineChart&gt; React 的核心思想View 是 State 的输出。 1view = f(state) 只要 State 发生变化，View 也要随之变化。 React 的本质是将图形界面（GUI）函数化。 12345678const person = &#123; name: \"michel\", age: 31&#125;const App = (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body) React 应用的架构React 只是一个 DOM 的抽象层，并没有解决应用程序的架构问题：大型应用程序应该如何组织代码？ Facebook 提出 Flux 架构的概念。 最大特点：数据单向流动 目前最流行的两个 React 架构React 架构的最重要作用：管理 Store 与 View 之间的关系。 MobX：响应式（Reative）管理，state 是可变对象，适合中小型项目 Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目 MobX 架构MobX 的核心是观察者模式。 Store 是被观察者（observable） 组件是观察者（observer） 一旦Store有变化，会立刻被组件观察到，从而引发重新渲染。 MobX 的最简单例子1234567891011const &#123;observable, computed&#125; = mobx;const &#123;observer&#125; = mobxReact;const person = observable(&#123;name: \"张三\", age: 31&#125;);const App = observer( (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;);ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);person.name = \"李四\"; 代码：demos/mobx-demo/browser-demo目录 示例：MobX进入demos/mobx-demo目录，按照《操作说明》，理解 MobX 框架。 UI 层是观察者，Store 是被观察者。 Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。 123456class Store &#123; @observable name = 'Bartek'; @computed get decorated() &#123; return `$&#123;this.name&#125; is awesome!`; &#125;&#125; UI 会观察到 Store 的变化，自动重新渲染。 Redux 架构Redux 的核心概念 所有的状态存放在Store。组件每次重新渲染，都必须由状态变化引起。 用户在 UI 上发出action。 reducer函数接收action，然后根据当前的state，计算出新的state。 示例：Redux进入demos/redux-demo目录，按照《操作说明》，理解 Redux 框架。 Redux 将组件分成 UI 组件和容器组件两类。 UI 组件是纯组件，需要用户自己写。 1234567&lt;div className=\"index\"&gt; &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;this.props.name&#125; onChange=&#123;this.props.onChange&#125; /&gt;&lt;/div&gt; 容器组件在用户给出配置以后，由 Redux 生成。 12345// MyComponent 是纯的 UI 组件const App = connect( mapStateToProps, mapDispatchToProps)(MyComponent); mapStateToProps: 定义 UI 组件参数与 State 之间的映射 mapDispatchToProps：定义 UI 组件与 Action 之间的映射 reducer是一个纯函数，用来接收action，算出新的state。 123456789101112function reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; &#125;&#125; Store由 Redux 提供的createStore方法生成，该方法接受reducer作为参数。 为了把Store传入组件，必须使用 Redux 提供的Provider组件在应用的最外面，包裹一层。 12345678const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.body.appendChild(document.createElement('div'))); Node 应用开发 Node 简介Node 是服务器的 JavaScript 运行环境，提供 API 与操作系统互动。 主要用途： 开发前端应用 快速搭建服务 架设网站 npm安装 Node 的时候，会同时安装 npm。 1$ npm -v 它是 Node 的模块管理器，开发 Node 项目的必备工具。 课堂练习：Node 的简单应用进入demos/simple-app-demo目录，参考《操作指南》，自己动手在 Node 里面，编写并编译一个前端脚本。 Node 开发前端脚本的好处 模块机制 版本管理 对外发布 持续集成的标准开发流程 REST APIREST 是浏览器与服务器通信方式的一种设计风格。 它的全称是“REpresentational State Transfer”，中文意为”表现层状态转换“。 Resource：资源 Representation：表现层 State：状态 Transfer：转换 REST 的核心概念 互联网上所有可以访问的内容，都是资源。 服务器保存资源，客户端请求资源。 同一个资源，有多种表现形式。 协议本身不带有状态，通信时客户端必须通过参数，表示请求不同状态的资源。 状态转换通过HTTP动词表示。 URL 设计URL 是资源的唯一识别符。 /store/1 /store/2 /store/1/employee/2 查询字符串查询字符串表示对所请求资源的约束条件。 GET /zoos/1/animals?limit=10 GET /zoos/1/animals?limit=10&amp;offset=10 GET /animals?zoo_id=1 HTTP 动词 操作 SQL方法 HTTP动词 CREATE INSERT POST READ SELECT GET UPDATE UPDATE PUT/PATCH DELETE DELETE DELETE 1234GET /v1/stores/1234PUT /v1/stores/1234POST /v1/storesDELETE /v1/stores/1234 课堂练习：REST API打开demos/rest-api-demo，按照《操作指南》，熟悉 REST API 的基本用法。 ExpressExpress 是最常用的 Node 框架，用来搭建 Web 应用。 课堂练习：Express 搭建 Web 应用进入demos/express-demo目录，按照《操作指南》，学习使用 Express 搭建 Web 应用。 定义一个 Web 应用实例，并且启动它。 1234567var express = require('express');var app = express();var port = process.env.PORT || 8080;app.listen(port);console.log('Magic happens on port ' + port); 定义一个路由 1234567var router = express.Router();router.get('/', function(req, res) &#123; res.send('&lt;h1&gt;Hello World&lt;/h1&gt;');&#125;);app.use('/home', router); 中间件：对 HTTP 请求进行加工。 1234router.use(function(req, res, next) &#123; console.log('There is a requesting.'); next();&#125;); 前端工程简介 持续集成流程前端开发转移到后端环境，意味着可以适用标准的软件工程流程。 本地开发（developing） 静态代码检查（linting） 单元测试（testing） 合并进入主干（merging） 自动构建（building） 自动发布（publishing） 持续集成的概念Continuous integration（简称 CI）： 开发代码频繁地合并进主干，始终保持可发布状态的这个过程。 优点 快速发现错误 防止分支大幅偏离主干 让产品可以快速迭代，同时还能保持高质量 ESLint：静态代码检查工具 发现语法错误 发现风格错误 自动纠正错误 课堂练习：ESLint 的用法进入demos/eslint-demo目录，按照《操作指南》，完成练习。 为什么写测试？Web 应用越来越复杂，意味着更可能出错。测试是提高代码质量、降低错误的最好方法之一。 测试可以确保得到预期结果。 加快开发速度。 方便维护。 提供用法的文档。 对于长期维护的项目，测试可以减少投入时间，减轻维护难度。 测试的类型 单元测试（unit testing） 功能测试（feature testing） 集成测试（integration testing） 端对端测试 (End-to-End testing） 以测试为导向的开发模式 TDD：测试驱动的开发（Test-Driven Development） BDD：行为驱动的开发（Behavior-Driven Development） 它们都要求先写测试，再写代码。 思考题：测试导向的开发模式有明显的优点，为什么现实生活中采用的人不多？ TDD vs. BDD两者侧重点不一样 TDD：基于开发者角度，重点测试函数的输入输出 BDD：基于使用者角度，重点测试对用户行为的反应 比如，有一个计数器函数counter，TDD 测试的是输入1，输出的应该是2；BDD 测试的是用户访问以后，计数器应该增加一次。 MochaMocha 是目前最常用的测试框架。 课堂练习：Mocha 的用法进入demos/mocha-demo目录，按照《操作指南》，练习写单元测试。 功能测试功能测试指的是，站在外部用户的角度，测试软件的某项功能。 与内部代码实现无关，只测试功能是否正常。 很多时候，单元测试都可以通过，但是整体功能会失败。 前端的功能测试功能测试必须在真正浏览器做，现在有四种方法。 使用本机安装的浏览器 使用 Selenium Driver 使用 PhantomJS 使用 Electron Nightmare 使用 Electron 模拟真实浏览器环境 提供大量人性化、易用的 API 官网：nightmarejs.org 示例：Nightmare打开demos/nightmare-demo/，按照《操作说明》，完成操作。 移动平台的自动化测试目前，最常见的方案是使用 Appium。 基于 WebDriver 采用 客户端/服务器架构 可以在模拟器运行，也可以在真机运行 Appium 测试流程 WebDriver 客户端发出测试请求和测试内容 Appium 服务器转发到相应的测试运行器（Driver） iOS 设备是 UIAutomation，安卓设备是 UiAutomator 测试运行器将运行结果，返回给 Appium 持续集成服务平台代码合并进主干以后，就可以进行自动构建和发布了。 网上有很多 PaaS 平台，提供持续集成服务。 Travis CI 就是其中最著名的一个，它可以根据你提供的脚本，自动完成构建和发布。 课堂练习：Travis CI按照《操作说明》，完成练习。 所有内容都配有 Demo 和操作指导，帮助读者边学边练，保证学会。 我已经找了一个场合，试讲了一次上面的内容，觉得效果还可以。本教程采用 GPL 许可证，你可以自由地使用它，唯一的条件是如果对内容做出任何改进，你也必须在 GPL 许可证下开源。我也接受现场培训。如果你们公司有这个需要，可以联系我。不过，讲课费比较贵，所以还是推荐大家自学。（完） 以上内容全都转自阮一峰博客，自由转载非商用","tags":[{"name":"web前端","slug":"web前端","permalink":"http://yoursite.com/tags/web前端/"}]},{"title":"如何在6个月内学会英语","date":"2016-12-10T02:33:00.000Z","path":"2016/12/10/zwh8/","text":"&emsp;&emsp;整个过程就是试错，得到反馈，迅速纠正，练习，继续循环，最终学会。","tags":[{"name":"英语","slug":"英语","permalink":"http://yoursite.com/tags/英语/"}]},{"title":"游戏纯属爱好","date":"2016-12-09T07:28:00.000Z","path":"2016/12/09/zwh6/","text":"&emsp;&emsp;小的时候玩什么？2007年我才学会自己申请QQ，那时候记性不好，还把QQ号写在纸上，去网吧的时候，老是揣个小纸条儿。&emsp;&emsp;QQ差不多玩儿了一年多不知不觉就记住了，不可否认的说，那时候确实沉迷游戏，小游戏玩小霸王游戏机的超级玛丽，大游戏到Ps4的铁拳，那时候去网吧简直就是一种奢华，平时都是玩儿街机，就投币那种，一块钱10个币，后来玩的多了，就开始联机玩儿GTA和一些主流的单机盗版游戏，什么单机CF，单机DNF就没有不玩儿的，每天10块钱的零花钱，全都省吃俭用的留下来，买盗版光碟，装单机游戏玩儿，就随便一个游戏能玩儿好几个月，下面来介绍一下我玩儿过的感觉比较经典的单机游戏 1.真三国无双 那时候是我第一次接触到这种日本制作的三国题材的大型单机游戏，当时用的配的垃圾联想电脑，集成显卡，G610，也就只能玩玩这种低端的，配置要求不是很高。 2.GTA 圣安地列斯 神龙 控制汽车 杰森和布莱迪 外星人国度 王尼玛 假面骑士 核弹 岛屿 总的来说GTA真是帅，真是神，啥都能改，啥都能做，属于一个高度自由的可编辑单机游戏，凡是你觉得有意思的东西都可以弄到游戏里面来玩儿，可联机可单机，上可九天揽月，下可五洋捉鳖，可能大家看我说的这么牛逼，就想说，你咋不上天呢？恩，没错，这游戏确实可以送你上天 最后帖上一张我大GTA5的model龙图","tags":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"}]},{"title":"你死了之后，身体会怎么样？","date":"2016-12-09T07:22:00.000Z","path":"2016/12/09/zwh5/","text":"死后之谜","tags":[{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"}]},{"title":"灾难电影——隧道","date":"2016-12-09T02:36:00.000Z","path":"2016/12/09/zwh4/","text":"灾难面前，生命如此卑微，如此渺小，政府的漠视，终究还是信念和坚守打败了一切~","tags":[{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"}]},{"title":"为什么人的脚为什么比人的脸和手都要白呢？因为它老藏着。","date":"2016-12-07T10:36:00.000Z","path":"2016/12/07/zwh3/","text":"一生中最佩服的历史人物司马懿，懂得忍辱负重，待时而起的大才之人。","tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":" 今年我给自己定了三个目标","date":"2016-12-07T09:42:00.000Z","path":"2016/12/07/zwh2/","text":"生于忧患死于安乐，要想在这看似动荡浮躁的时代安身立命唯有找一份事业,认真踏实去干; 一直干到如同庖丁解牛的境界。 这样，身也安了,命也立了。 就是这样。1.学会并使用web三大框架(React.js、Vue.js、AngularJs)增加知识面 2.搞定英语三级课程 3.在高新区找一份新工作 箭在弦上，不得不发。","tags":[{"name":"目标","slug":"目标","permalink":"http://yoursite.com/tags/目标/"}]},{"title":" 2016年我第一次写博客","date":"2016-12-06T07:29:00.000Z","path":"2016/12/06/zwh1/","text":"&emsp;&emsp;小时候呢总想看看20岁的自己到底会变成什么样子，那时候哪会想到如今的自己居然是个碌碌无为的程序员，怪命运？还是自己？现在的我只想要过好当下的每一秒，哪怕是呼吸的那一秒，也要好好珍惜，因为我深知如今的我不可以再像从前了，这里引用我曾经看到过的一句话，人一旦看到真相了，就很难再闭上眼睛假装不知道。","tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]}]